#!/usr/bin/env bash
# ====App Healthcheck>>=========================================================
#  PTEKWPDEV — Application Layer Healthcheck
#  Evaluates bootstrap, deploy, assets, and project readiness.
# ====<<App Healthcheck=========================================================
set -Eeuo pipefail

# -----------------------------------------------------------------------------
# Resolve APP_BASE
# -----------------------------------------------------------------------------
PTEK_APP_BASE="$(
  cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd
)"
export PTEK_APP_BASE

# -----------------------------------------------------------------------------
# Default logging verbosity for output.sh
# -----------------------------------------------------------------------------
PTEK_VERBOSE=1
export PTEK_VERBOSE

# ========================================================================
# DO NOT EDIT THIS BLOCK — generated by script_new.sh
# ========================================================================

# ====Error Handling>>=====================================
_ts() { date +"%Y-%m-%d %H:%M:%S"; }
ptek_err() { COLOR_RED="\033[31m"; COLOR_RESET="\033[0m"; echo -e "${COLOR_RED}[$(_ts)] ERROR: $*${COLOR_RESET}" >&2; }

CALLER_PWD="$(pwd)"
trap 'ptek_err "Command failed (exit $?): $BASH_COMMAND"' ERR
trap 'cd "$CALLER_PWD" || true' EXIT
# ====<<Error Handling=====================================

# ====App Config>>=========================================
# shellcheck source=/dev/null
source "${PTEK_APP_BASE}/lib/app_config.sh"
# ====<<App Config=========================================

# ========================================================================
# END GENERATED BLOCK
# ========================================================================

# ------------------------------------------------------------------------------
# Flags
# ------------------------------------------------------------------------------
USE_VERBOSE=false

usage() {
  cat <<EOF
Usage: app_healthcheck.sh [-v] [-h]

Options:
  -v, --verbose     Enable verbose output
  -h, --help        Show this help message

Evaluates bootstrap, deploy, assets, and project readiness.
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -v|--verbose) USE_VERBOSE=true ;;
    -h|--help) usage; exit 0 ;;
    *) error "Unknown option: $1"; usage; exit 1 ;;
  esac
  shift
done

# ------------------------------------------------------------------------------
# Verbose wrappers — boolean-safe, strict-mode-safe
# ------------------------------------------------------------------------------
vinfo()    { if [[ $USE_VERBOSE == true ]]; then info "$*"; fi; }
vsuccess() { if [[ $USE_VERBOSE == true ]]; then success "$*"; fi; }
vwarn()    { if [[ $USE_VERBOSE == true ]]; then warn "$*"; fi; }
verror()   { if [[ $USE_VERBOSE == true ]]; then error "$*"; fi; }

# ------------------------------------------------------------------------------
# Initialize log
# ------------------------------------------------------------------------------
set_log --truncate "$(appcfg app_log_dir)/app_healthcheck.log" \
  "=== App Healthcheck Run ($(date)) ==="

test_sym=$(appcfg dummy_token) && true
echo "Test Config Entry=$test_sym"

# ------------------------------------------------------------------------------
# Load compose file for container detection
# ------------------------------------------------------------------------------
COMPOSE_FILE="${PTEK_APP_BASE}/config/docker/compose.app.yml"

if [[ ! -f "$COMPOSE_FILE" ]]; then
  verror "compose.app.yml not found"
fi

# Extract container names
DB_CONTAINER="$(grep -E 'container_name:' "$COMPOSE_FILE" | grep -E 'db' | awk '{print $2}' || true)"
ADMIN_CONTAINER="$(grep -E 'container_name:' "$COMPOSE_FILE" | grep -E 'admin' | awk '{print $2}' || true)"

# Fallbacks if container_name not defined
DB_CONTAINER="${DB_CONTAINER:-ptekwpdev_db}"
ADMIN_CONTAINER="${ADMIN_CONTAINER:-ptekwpdev_admin}"

vinfo "DB container: $DB_CONTAINER"
vinfo "Admin container: $ADMIN_CONTAINER"

# ------------------------------------------------------------------------------
# State buckets
# ------------------------------------------------------------------------------
BOOTSTRAP="Pending"
DEPLOY="Pending"
ASSETS="Pending"
PROJECTS="Pending"

# ------------------------------------------------------------------------------
# BOOTSTRAP CHECKS
# ------------------------------------------------------------------------------
vinfo "Checking bootstrap state..."

BOOTSTRAP_OK=true

# app.json exists
if [[ -f "$(appcfg app_config_dir)/app.json" ]]; then
  vsuccess "app.json present"
else
  vwarn "app.json missing"
  BOOTSTRAP_OK=false
fi

# app_config.sh loads (already loaded above)
vsuccess "app_config.sh loaded"

# required directories
for d in "$(appcfg app_base)" "$(appcfg app_log_dir)"; do
  if [[ -d "$d" ]]; then
    vsuccess "Directory OK: $d"
  else
    vwarn "Missing directory: $d"
    BOOTSTRAP_OK=false
  fi
done

if $BOOTSTRAP_OK; then
  BOOTSTRAP="Ready"
else
  BOOTSTRAP="Incomplete"
fi

# ------------------------------------------------------------------------------
# DEPLOY CHECKS (DB required, SQLAdmin optional)
# ------------------------------------------------------------------------------
vinfo "Checking deploy state..."

# DB container exists?
if docker ps -a --format '{{.Names}}' | grep -q "^${DB_CONTAINER}\$"; then
  vsuccess "DB container exists"
else
  vwarn "DB container missing"
  DEPLOY="Pending"
  goto_deploy_done=true
fi

# If DB missing, skip deeper checks
if [[ "${goto_deploy_done:-false}" == true ]]; then
  :
else
  # DB running?
  if docker ps --format '{{.Names}}' | grep -q "^${DB_CONTAINER}\$"; then
    vsuccess "DB container running"
  else
    vwarn "DB container exists but not running"
    DEPLOY="Incomplete"
    goto_deploy_done=true
  fi
fi

# If DB not running, skip DB health
if [[ "${goto_deploy_done:-false}" == true ]]; then
  :
else
  # DB reachable?
  if docker exec "$DB_CONTAINER" sh -c "mysqladmin ping -h localhost --silent"; then
    vsuccess "DB reachable"
    DEPLOY="Ready"
  else
    verror "DB unreachable"
    DEPLOY="Issues"
  fi
fi

# SQLAdmin is optional — only warn if present but broken
if docker ps -a --format '{{.Names}}' | grep -q "^${ADMIN_CONTAINER}\$"; then
  if docker ps --format '{{.Names}}' | grep -q "^${ADMIN_CONTAINER}\$"; then
    vsuccess "SQLAdmin running"
  else
    vwarn "SQLAdmin exists but not running (optional)"
  fi
else
  vinfo "SQLAdmin not present (optional)"
fi

# ------------------------------------------------------------------------------
# ASSETS CHECKS
# ------------------------------------------------------------------------------
vinfo "Checking assets state..."

ASSETS_CONTAINER="$(appcfg assets.container)"
ASSETS_VOLUME="$(appcfg assets.volume_name)"
ASSETS_ROOT="$(appcfg assets.root_path)"

ASSETS_OK=true

# container exists?
if docker ps -a --format '{{.Names}}' | grep -q "^${ASSETS_CONTAINER}\$"; then
  vsuccess "Assets container exists"
else
  vinfo "Assets container missing"
  ASSETS="Pending"
  ASSETS_OK=false
fi

# running?
if $ASSETS_OK; then
  if docker ps --format '{{.Names}}' | grep -q "^${ASSETS_CONTAINER}\$"; then
    vsuccess "Assets container running"
  else
    vwarn "Assets container exists but not running"
    ASSETS="Incomplete"
    ASSETS_OK=false
  fi
fi

# volume?
if docker volume ls --format '{{.Name}}' | grep -q "^${ASSETS_VOLUME}\$"; then
  vsuccess "Assets volume exists"
else
  vwarn "Assets volume missing"
  ASSETS="Incomplete"
  ASSETS_OK=false
fi

# directory structure?
if $ASSETS_OK; then
  if docker exec "$ASSETS_CONTAINER" test -d "$ASSETS_ROOT"; then
    vsuccess "Assets root exists"
  else
    verror "Assets root missing"
    ASSETS="Issues"
    ASSETS_OK=false
  fi
fi

if $ASSETS_OK; then
  ASSETS="Ready"
fi

# ------------------------------------------------------------------------------
# PROJECTS CHECKS
# ------------------------------------------------------------------------------
vinfo "Checking projects state..."

PROJECTS_DIR="$(appcfg project_base)"

if [[ ! -d "$PROJECTS_DIR" ]]; then
  vinfo "No projects directory"
  PROJECTS="Pending"
else
  # any project directories?
  if find "$PROJECTS_DIR" -mindepth 1 -maxdepth 1 -type d | read -r _; then
    vsuccess "Project(s) found"
    PROJECTS="Ready"
  else
    vinfo "Projects directory empty"
    PROJECTS="Pending"
  fi
fi

# ------------------------------------------------------------------------------
# FINAL OUTPUT
# ------------------------------------------------------------------------------
echo ""
info "=== App State ==="
echo "BOOTSTRAP: $BOOTSTRAP"
echo "DEPLOY:    $DEPLOY"
echo "ASSETS:    $ASSETS"
echo "PROJECTS:  $PROJECTS"
echo ""

success "App healthcheck completed."