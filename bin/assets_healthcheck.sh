#!/usr/bin/env bash
# ====Assets Healthcheck>>=====================================================
#  PTEKWPDEV — Assets Healthcheck Script
#  Script: bin/assets_healthcheck.sh
#
#  Pure diagnostics — never mutates state.
# ====<<Assets Healthcheck=====================================================
set -Eeuo pipefail

# -----------------------------------------------------------------------------
# Ensure logging library has a default verbosity value BEFORE sourcing output.sh
# -----------------------------------------------------------------------------
PTEK_VERBOSE=1
export PTEK_VERBOSE

# -----------------------------------------------------------------------------
# Resolve APP_BASE
# -----------------------------------------------------------------------------
PTEK_APP_BASE="$(
  cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd
)"
export PTEK_APP_BASE

# ========================================================================
# DO NOT EDIT THIS BLOCK — generated by script_new.sh
# ========================================================================

# ====Error Handling>>=====================================
_ts() { date +"%Y-%m-%d %H:%M:%S"; }
ptek_err() { COLOR_RED="\033[31m"; COLOR_RESET="\033[0m"; echo -e "${COLOR_RED}[$(_ts)] ERROR: $*${COLOR_RESET}" >&2; }

CALLER_PWD="$(pwd)"
trap 'ptek_err "Command failed (exit $?): $BASH_COMMAND"' ERR
trap 'cd "$CALLER_PWD" || true' EXIT
# ====<<Error Handling=====================================

# ====App Config>>=========================================
# shellcheck source=/dev/null
source "${PTEK_APP_BASE}/lib/app_config.sh"
# ====<<App Config=========================================

# ========================================================================
# END GENERATED BLOCK
# ========================================================================

# ------------------------------------------------------------------------------
# Flags
# ------------------------------------------------------------------------------
USE_VERBOSE=false

usage() {
  cat <<EOF
Usage: assets_healthcheck.sh [-v] [-h]

Options:
  -v, --verbose     Enable verbose output
  -h, --help        Show this help message

Pure diagnostics — never mutates state.
EOF
}

# ------------------------------------------------------------------------------
# Parse flags BEFORE defining wrappers or initializing logs
# ------------------------------------------------------------------------------
while [[ $# -gt 0 ]]; do
  case "$1" in
    -v|--verbose) USE_VERBOSE=true ;;
    -h|--help) usage; exit 0 ;;
    *) error "Unknown option: $1"; usage; exit 1 ;;
  esac
  shift
done

# ------------------------------------------------------------------------------
# Verbose wrappers — DO NOT call info/success/warn/error
# ------------------------------------------------------------------------------
vinfo()    { if [[ $USE_VERBOSE == true ]]; then info "$*"; fi; }
vsuccess() { if [[ $USE_VERBOSE == true ]]; then success "$*"; fi; }
vwarn()    { if [[ $USE_VERBOSE == true ]]; then warn "$*"; fi }
verror()   { if [[ $USE_VERBOSE == true ]]; then error "$*"; fi }

# ------------------------------------------------------------------------------
# Initialize logging AFTER flags are parsed (so -h does not truncate logs)
# ------------------------------------------------------------------------------
set_log --truncate "$(appcfg app_log_dir)/assets_healthcheck.log" \
  "=== Assets Healthcheck Run ($(date)) ==="

# ------------------------------------------------------------------------------
# Resolve config values
# ------------------------------------------------------------------------------
ASSETS_CONTAINER="$(appcfg assets.container)"
ASSETS_ROOT="$(appcfg assets.root_path)"
ASSETS_VOLUME="$(appcfg assets.volume_name)"

ASSETS_DOCKER_DIR="$(appcfg app_assets_dir)/docker"
ASSETS_COMPOSE_FILE="${ASSETS_DOCKER_DIR}/compose.assets.yml"
ASSETS_DOCKERFILE="${ASSETS_DOCKER_DIR}/Dockerfile"

# ------------------------------------------------------------------------------
# Summary state
# ------------------------------------------------------------------------------
declare -A SUMMARY=(
  [templates]="PENDING"
  [container_exists]="PENDING"
  [container_running]="PENDING"
  [volume]="PENDING"
  [structure]="PENDING"
  [permissions]="PENDING"
  [sync_check]="PENDING"
)

# ------------------------------------------------------------------------------
# Check 1: Dockerfile + compose presence
# ------------------------------------------------------------------------------
check_templates() {
  vinfo "Checking assets Docker templates..."

  if [[ -f "$ASSETS_DOCKERFILE" && -f "$ASSETS_COMPOSE_FILE" ]]; then
    vsuccess "Docker templates present"
    SUMMARY[templates]="OK"
  else
    verror "Missing Docker templates"
    SUMMARY[templates]="FAIL"
  fi
}

# ------------------------------------------------------------------------------
# Check 2: Container existence
# ------------------------------------------------------------------------------
check_container_exists() {
  vinfo "Checking if assets container exists..."

  if docker ps -a --format '{{.Names}}' | grep -q "^${ASSETS_CONTAINER}\$"; then
    vsuccess "Container exists: ${ASSETS_CONTAINER}"
    SUMMARY[container_exists]="OK"
  else
    verror "Container does not exist: ${ASSETS_CONTAINER}"
    SUMMARY[container_exists]="FAIL"
  fi
}

# ------------------------------------------------------------------------------
# Check 3: Container running state
# ------------------------------------------------------------------------------
check_container_running() {
  vinfo "Checking if assets container is running..."

  # If it doesn't exist, skip this check
  if [[ "${SUMMARY[container_exists]}" == "FAIL" ]]; then
    vwarn "Skipping running check: container does not exist"
    SUMMARY[container_running]="N/A"
    return
  fi

  if docker ps --format '{{.Names}}' | grep -q "^${ASSETS_CONTAINER}\$"; then
    vsuccess "Container is running"
    SUMMARY[container_running]="OK"
  else
    vwarn "Container exists but is not running"
    SUMMARY[container_running]="WARN"
  fi
}

# ------------------------------------------------------------------------------
# Check 4: Volume existence
# ------------------------------------------------------------------------------
check_volume_exists() {
  vinfo "Checking assets volume..."

  if docker volume ls --format '{{.Name}}' | grep -q "^${ASSETS_VOLUME}\$"; then
    vsuccess "Volume exists: ${ASSETS_VOLUME}"
    SUMMARY[volume]="OK"
  else
    verror "Volume does not exist: ${ASSETS_VOLUME}"
    SUMMARY[volume]="FAIL"
  fi
}

# ------------------------------------------------------------------------------
# Check 5: Validate assets_root directory structure inside container
# ------------------------------------------------------------------------------
check_assets_structure() {
  vinfo "Checking assets directory structure inside container..."

  if ! docker exec "$ASSETS_CONTAINER" test -d "$ASSETS_ROOT"; then
    verror "assets_root does not exist inside container: $ASSETS_ROOT"
    SUMMARY[structure]="FAIL"
    return
  fi

  vsuccess "assets_root exists: $ASSETS_ROOT"
  SUMMARY[structure]="OK"

  # TODO: Make expected subdirectories config-driven
  local dirs=(plugins themes uploads)
  for d in "${dirs[@]}"; do
    if docker exec "$ASSETS_CONTAINER" test -d "$ASSETS_ROOT/$d"; then
      vsuccess "Found: $ASSETS_ROOT/$d"
    else
      vwarn "Missing: $ASSETS_ROOT/$d"
    fi
  done
}

# ------------------------------------------------------------------------------
# Check 6: Read/write permissions inside container
# ------------------------------------------------------------------------------
check_permissions() {
  vinfo "Checking read/write permissions inside container..."

  local testfile="$ASSETS_ROOT/.healthcheck_test_$$"

  if docker exec "$ASSETS_CONTAINER" sh -c "touch $testfile && rm -f $testfile"; then
    vsuccess "Container has read/write access to assets_root"
    SUMMARY[permissions]="OK"
  else
    verror "Container lacks read/write access to assets_root"
    SUMMARY[permissions]="FAIL"
  fi
}

# ------------------------------------------------------------------------------
# ENV + Compose Sync Check
# ------------------------------------------------------------------------------
assets_config_check() {
  vinfo "Checking .env and compose file sync..."

  ENV_FILE="${ASSETS_DOCKER_DIR}/.env"
  COMPOSE_FILE="${ASSETS_DOCKER_DIR}/compose.assets.yml"

  SYNC_OK=true

  # 1. Ensure .env exists
  if [[ ! -f "$ENV_FILE" ]]; then
    verror ".env file missing: $ENV_FILE"
    SYNC_OK=false
  else
    vsuccess ".env file present"
  fi

  # 2. Extract all ${VAR} placeholders from compose file
  mapfile -t compose_vars < <(grep -o '\${[^}]*}' "$COMPOSE_FILE" | tr -d '${}')

  # 3. Extract all VAR= entries from .env
  mapfile -t env_vars < <(cut -d= -f1 "$ENV_FILE")

  # 4. Check each compose var exists in .env
  for var in "${compose_vars[@]}"; do
    if ! printf '%s\n' "${env_vars[@]}" | grep -qx "$var"; then
      verror "Missing variable in .env: $var"
      SYNC_OK=false
    else
      vsuccess "Variable present: $var"
    fi
  done

  # 5. Check each .env var exists in compose file
  for var in "${env_vars[@]}"; do
    if ! printf '%s\n' "${compose_vars[@]}" | grep -qx "$var"; then
      vwarn "Variable in .env not used in compose: $var"
    fi
  done

  # 6. Check values match PTEKWPCFG
  for var in "${env_vars[@]}"; do
    expected="$(appcfg "${var,,}")" || expected=""
    actual="$(grep "^${var}=" "$ENV_FILE" 2>/dev/null || true)"
    actual="${actual#*=}"

    if [[ -n "$expected" && "$expected" != "$actual" ]]; then
      verror "Value mismatch for $var: expected '$expected', found '$actual'"
      SYNC_OK=false
    fi
  done

  if $SYNC_OK; then
    vsuccess ".env and compose file are in sync"
    SUMMARY[sync_check]="OK"

  else
    verror ".env and compose file are NOT in sync"
    SUMMARY[sync_check]="FAIL"
  fi  
}

# ------------------------------------------------------------------------------
# Run all checks
# ------------------------------------------------------------------------------
vinfo "Starting assets healthcheck..."

check_templates
check_container_exists
check_container_running
check_volume_exists
check_assets_structure
check_permissions
assets_config_check

# ------------------------------------------------------------------------------
# Summary (always printed)
# ------------------------------------------------------------------------------
echo ""
info "=== SUMMARY ==="

printf "Templates:         %s\n" "${SUMMARY[templates]}"
printf "Container Exists:  %s\n" "${SUMMARY[container_exists]}"
printf "Running:           %s\n" "${SUMMARY[container_running]}"
printf "Volume:            %s\n" "${SUMMARY[volume]}"
printf "Structure:         %s\n" "${SUMMARY[structure]}"
printf "Permissions:       %s\n" "${SUMMARY[permissions]}"
printf "Env/Compose Sync:  %s\n" "${SUMMARY[sync_check]}"

echo ""

success "Assets healthcheck completed."